
R version 3.5.3 (2019-03-11) -- "Great Truth"
Copyright (C) 2019 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "sensorsUtils"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> base::assign(".ExTimings", "sensorsUtils-Ex.timings", pos = 'CheckExEnv')
> base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
> base::assign(".format_ptime",
+ function(x) {
+   if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
+   if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
+   options(OutDec = '.')
+   format(x[1L:3L], digits = 7L)
+ },
+ pos = 'CheckExEnv')
> 
> ### * </HEADER>
> library('sensorsUtils')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("fortify_df")
> ### * fortify_df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fortify_df
> ### Title: Create a fortified dataframe.
> ### Aliases: fortify_df
> 
> ### ** Examples
> 
> 
> #One column dataframe with silent lost observations
> start <- as.POSIXct("2019/01/01")
> end   <- as.POSIXct("2019/01/02")
> dates <- seq(start, end, by = "hour")
> df.simple <- data.frame(dates = dates[-(sample(1:25,5))], values=rep(1,20))
> fortify_df(df=df.simple, by="hour")
                 dates values
1  2019-01-01 00:00:00      1
2  2019-01-01 01:00:00      1
3  2019-01-01 02:00:00      1
4  2019-01-01 03:00:00      1
5  2019-01-01 04:00:00     NA
6  2019-01-01 05:00:00      1
7  2019-01-01 06:00:00     NA
8  2019-01-01 07:00:00      1
9  2019-01-01 08:00:00     NA
10 2019-01-01 09:00:00      1
11 2019-01-01 10:00:00      1
12 2019-01-01 11:00:00      1
13 2019-01-01 12:00:00      1
14 2019-01-01 13:00:00     NA
15 2019-01-01 14:00:00      1
16 2019-01-01 15:00:00      1
17 2019-01-01 16:00:00      1
18 2019-01-01 17:00:00      1
19 2019-01-01 18:00:00      1
20 2019-01-01 19:00:00     NA
21 2019-01-01 20:00:00      1
22 2019-01-01 21:00:00      1
23 2019-01-01 22:00:00      1
24 2019-01-01 23:00:00      1
25 2019-01-02 00:00:00      1
> 
> #Multiple column dataframe with silent lost observations
> df.complex <- data.frame(dates = dates[-(sample(1:25,5))], A = 1:20, B = LETTERS[1:20], C = rnorm(1:20))
> fortify_df(df=df.complex, by="hour")
                 dates  A    B           C
1  2019-01-01 00:00:00  1    A -0.82046838
2  2019-01-01 01:00:00 NA <NA>          NA
3  2019-01-01 02:00:00  2    B  0.48742905
4  2019-01-01 03:00:00  3    C  0.73832471
5  2019-01-01 04:00:00  4    D  0.57578135
6  2019-01-01 05:00:00  5    E -0.30538839
7  2019-01-01 06:00:00  6    F  1.51178117
8  2019-01-01 07:00:00  7    G  0.38984324
9  2019-01-01 08:00:00  8    H -0.62124058
10 2019-01-01 09:00:00  9    I -2.21469989
11 2019-01-01 10:00:00 10    J  1.12493092
12 2019-01-01 11:00:00 11    K -0.04493361
13 2019-01-01 12:00:00 12    L -0.01619026
14 2019-01-01 13:00:00 NA <NA>          NA
15 2019-01-01 14:00:00 13    M  0.94383621
16 2019-01-01 15:00:00 NA <NA>          NA
17 2019-01-01 16:00:00 14    N  0.82122120
18 2019-01-01 17:00:00 15    O  0.59390132
19 2019-01-01 18:00:00 16    P  0.91897737
20 2019-01-01 19:00:00 17    Q  0.78213630
21 2019-01-01 20:00:00 18    R  0.07456498
22 2019-01-01 21:00:00 19    S -1.98935170
23 2019-01-01 22:00:00 NA <NA>          NA
24 2019-01-01 23:00:00 20    T  0.61982575
> 
> # Multiple datafrems with silent lost observations
> df.A <- data.frame(dates = dates[-(sample(1:25,5))], a = 1:20)
> df.B <- data.frame(dates = dates[-(sample(1:25,3))], a = 1:22)
> df.C <- data.frame(dates = dates[-(sample(1:25,7))], a = 1:18)
> fortify_df(list(df.A, df.B, df.C), by = "hour")
                 dates  A  B  C
1  2019-01-01 00:00:00  1  1  1
2  2019-01-01 01:00:00 NA  2  2
3  2019-01-01 02:00:00  2 NA  3
4  2019-01-01 03:00:00  3  3  4
5  2019-01-01 04:00:00  4  4  5
6  2019-01-01 05:00:00 NA  5  6
7  2019-01-01 06:00:00  5  6 NA
8  2019-01-01 07:00:00  6 NA  7
9  2019-01-01 08:00:00  7  7  8
10 2019-01-01 09:00:00  8  8 NA
11 2019-01-01 10:00:00 NA  9  9
12 2019-01-01 11:00:00 NA NA 10
13 2019-01-01 12:00:00  9 10 NA
14 2019-01-01 13:00:00 10 11 11
15 2019-01-01 14:00:00 11 12 12
16 2019-01-01 15:00:00 12 13 13
17 2019-01-01 16:00:00 13 14 NA
18 2019-01-01 17:00:00 14 15 14
19 2019-01-01 18:00:00 15 16 15
20 2019-01-01 19:00:00 16 17 16
21 2019-01-01 20:00:00 NA 18 NA
22 2019-01-01 21:00:00 17 19 NA
23 2019-01-01 22:00:00 18 20 17
24 2019-01-01 23:00:00 19 21 NA
25 2019-01-02 00:00:00 20 22 18
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fortify_df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("make.aggregation")
> ### * make.aggregation
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: make.aggregation
> ### Title: Aggregate dataframe with a function.
> ### Aliases: make.aggregation
> 
> ### ** Examples
> 
> # Mean of 3 day data by days
> a = as.POSIXct("2019/01/01", tz = "UTC")
> b = as.POSIXct("2019/01/03 23:00:00", tz = "UTC")
> df <- data.frame(dates = seq.POSIXt(a,b,"hour"), A = runif(24*3))
> make.aggregation(df, freq = 24, mean)
          x
1 0.5428091
2 0.5073825
3 0.4921008
> 
> # The same with multicolumn datadrame
> a = as.POSIXct("2019/01/01", tz = "UTC")
> b = as.POSIXct("2019/01/03 23:00:00", tz = "UTC")
> df<-data.frame(dates = seq.POSIXt(a,b,"hour"),
+               A = runif(24*3),
+               B = rep(1:3,each=24))
> make.aggregation(df, freq = 24, mean)
          A B
1 0.5203553 1
2 0.5038185 2
3 0.5047931 3
> 
> # The previus example but using a 12 hour mean
> a = as.POSIXct("2019/01/01", tz = "UTC")
> b = as.POSIXct("2019/01/03 23:00:00", tz = "UTC")
> df<-data.frame(dates = seq.POSIXt(a,b,"hour"),
+               A = runif(24*3),
+               B = rep(1:3,each=24))
> make.aggregation(df, freq = 12, mean)
          A B
1 0.4756882 1
2 0.4328755 1
3 0.6624650 2
4 0.5846378 2
5 0.4354637 3
6 0.5221378 3
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("make.aggregation", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.233 0.031 0.293 0.004 0.005 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
